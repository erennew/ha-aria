"""Tests for LLM refiner — Ollama polish for alias/description."""

import json
from unittest.mock import MagicMock, patch

import pytest

from aria.automation.llm_refiner import IMMUTABLE_KEYS, refine_automation


@pytest.fixture
def sample_automation():
    """A typical automation dict from template_engine."""
    return {
        "id": "aria_bedroom_motion_abc12345",
        "alias": "Bedroom: Bedroom Motion → Bedroom Light",
        "description": (
            "Generated by ARIA Pattern engine. "
            "Confidence: 85%, observed 47 times. "
            "Active: 2026-01-01T06:30:00 to 2026-02-19T06:45:00. "
            "Day type: workday."
        ),
        "triggers": [
            {
                "platform": "state",
                "entity_id": "binary_sensor.bedroom_motion",
                "to": "on",
                "for": {"seconds": 5},
            }
        ],
        "conditions": [{"condition": "time", "after": "06:00:00", "before": "22:00:00"}],
        "actions": [{"action": "light.turn_on", "target": {"area_id": "bedroom"}}],
        "mode": "single",
    }


class TestRefineSuccess:
    """Tests for successful LLM refinement."""

    @pytest.mark.asyncio
    async def test_refines_alias_and_description(self, sample_automation):
        """LLM output updates alias and description only."""
        llm_response = json.dumps(
            {
                "alias": "Motion-activated bedroom lights",
                "description": "Turns on bedroom lights when motion is detected during the day.",
            }
        )
        with patch("aria.automation.llm_refiner.ollama_chat", return_value=llm_response):
            result = await refine_automation(sample_automation)

        assert result["alias"] == "Motion-activated bedroom lights"
        assert result["description"] == "Turns on bedroom lights when motion is detected during the day."
        # Structure unchanged
        assert result["triggers"] == sample_automation["triggers"]
        assert result["conditions"] == sample_automation["conditions"]
        assert result["actions"] == sample_automation["actions"]
        assert result["mode"] == sample_automation["mode"]
        assert result["id"] == sample_automation["id"]

    @pytest.mark.asyncio
    async def test_partial_refinement_alias_only(self, sample_automation):
        """If LLM only returns alias, description stays original."""
        llm_response = json.dumps({"alias": "Better Alias"})
        with patch("aria.automation.llm_refiner.ollama_chat", return_value=llm_response):
            result = await refine_automation(sample_automation)

        assert result["alias"] == "Better Alias"
        assert result["description"] == sample_automation["description"]


class TestRefineRejection:
    """Tests for LLM output that attempts structural changes."""

    @pytest.mark.asyncio
    async def test_rejects_trigger_change(self, sample_automation):
        """LLM trying to modify triggers gets rejected."""
        llm_response = json.dumps(
            {
                "alias": "New Alias",
                "description": "New Desc",
                "triggers": [{"platform": "sun", "event": "sunset"}],
            }
        )
        with patch("aria.automation.llm_refiner.ollama_chat", return_value=llm_response):
            result = await refine_automation(sample_automation)

        # Should fall back to original — structural change detected
        assert result["alias"] == sample_automation["alias"]
        assert result["triggers"] == sample_automation["triggers"]

    @pytest.mark.asyncio
    async def test_rejects_action_change(self, sample_automation):
        """LLM trying to modify actions gets rejected."""
        llm_response = json.dumps(
            {
                "alias": "New Alias",
                "actions": [{"action": "lock.lock", "target": {"entity_id": "lock.front"}}],
            }
        )
        with patch("aria.automation.llm_refiner.ollama_chat", return_value=llm_response):
            result = await refine_automation(sample_automation)

        assert result["actions"] == sample_automation["actions"]
        assert result["alias"] == sample_automation["alias"]

    @pytest.mark.asyncio
    async def test_rejects_mode_change(self, sample_automation):
        """LLM trying to change mode gets rejected."""
        llm_response = json.dumps(
            {
                "alias": "New Alias",
                "mode": "parallel",
            }
        )
        with patch("aria.automation.llm_refiner.ollama_chat", return_value=llm_response):
            result = await refine_automation(sample_automation)

        assert result["mode"] == sample_automation["mode"]
        assert result["alias"] == sample_automation["alias"]

    @pytest.mark.asyncio
    async def test_rejects_id_change(self, sample_automation):
        """LLM trying to change id gets rejected."""
        llm_response = json.dumps(
            {
                "alias": "New Alias",
                "id": "hacked_id",
            }
        )
        with patch("aria.automation.llm_refiner.ollama_chat", return_value=llm_response):
            result = await refine_automation(sample_automation)

        assert result["id"] == sample_automation["id"]
        assert result["alias"] == sample_automation["alias"]


class TestRefineGracefulFallback:
    """Tests for failure modes that fall back to original."""

    @pytest.mark.asyncio
    async def test_empty_llm_response(self, sample_automation):
        """Empty response returns original."""
        with patch("aria.automation.llm_refiner.ollama_chat", return_value=""):
            result = await refine_automation(sample_automation)

        assert result == sample_automation

    @pytest.mark.asyncio
    async def test_invalid_json_response(self, sample_automation):
        """Non-JSON response returns original."""
        with patch("aria.automation.llm_refiner.ollama_chat", return_value="not json at all"):
            result = await refine_automation(sample_automation)

        assert result == sample_automation

    @pytest.mark.asyncio
    async def test_llm_exception(self, sample_automation):
        """Exception in LLM call returns original."""
        with patch("aria.automation.llm_refiner.ollama_chat", side_effect=Exception("timeout")):
            result = await refine_automation(sample_automation)

        assert result == sample_automation

    @pytest.mark.asyncio
    async def test_llm_returns_non_dict(self, sample_automation):
        """LLM returning a list or other non-dict returns original."""
        with patch("aria.automation.llm_refiner.ollama_chat", return_value="[1, 2, 3]"):
            result = await refine_automation(sample_automation)

        assert result == sample_automation


class TestRefineConfig:
    """Tests for model/timeout configuration."""

    @pytest.mark.asyncio
    async def test_custom_model(self, sample_automation):
        """Custom model name is passed to ollama_chat."""
        mock_chat = MagicMock(return_value=json.dumps({"alias": "Better"}))
        with patch("aria.automation.llm_refiner.ollama_chat", mock_chat):
            await refine_automation(sample_automation, model="llama3:8b")

        config_arg = mock_chat.call_args[1].get("config") or mock_chat.call_args[0][1]
        assert config_arg.model == "llama3:8b"

    @pytest.mark.asyncio
    async def test_custom_timeout(self, sample_automation):
        """Custom timeout is passed to ollama_chat."""
        mock_chat = MagicMock(return_value=json.dumps({"alias": "Better"}))
        with patch("aria.automation.llm_refiner.ollama_chat", mock_chat):
            await refine_automation(sample_automation, timeout=15)

        config_arg = mock_chat.call_args[1].get("config") or mock_chat.call_args[0][1]
        assert config_arg.timeout == 15


class TestImmutableKeys:
    """Tests for the immutability contract."""

    def test_immutable_keys_defined(self):
        """IMMUTABLE_KEYS should cover all structural fields."""
        assert "id" in IMMUTABLE_KEYS
        assert "triggers" in IMMUTABLE_KEYS
        assert "conditions" in IMMUTABLE_KEYS
        assert "actions" in IMMUTABLE_KEYS
        assert "mode" in IMMUTABLE_KEYS

    def test_alias_not_immutable(self):
        assert "alias" not in IMMUTABLE_KEYS

    def test_description_not_immutable(self):
        assert "description" not in IMMUTABLE_KEYS
